---
icon: pen-to-square
date: 2020-05-05
category:
        - Java
tag:
        - 并发
        - 多线程
---

# 《线程池》

> 什么是线程池？

就是有多条线程存放在一个池子中，供我们使用。

> 为什么不自己创建线程而使用线程池？

1. 降低资源消耗
   创建和销毁线程是昂贵的，因为涉及到与操作系统交互的过程。频繁地创建和销毁线程会导致显著的性能开销。线程池通过重用已有线程来减少这种开销，因为线程一旦创建就可以被多个任务复用，避免了频繁的创建和销毁。

2. 提高响应速度
   当任务到达时，任务可以不需要等待线程创建就立即执行。因为线程池中的线程已经预先创建好，等待工作，这样可以减少任务的启动时间，提高系统的响应速度。

3. 提高线程的可管理性
   线程是稀缺资源，如果无限制地创建，很容易耗尽系统资源，导致系统崩溃。线程池可以统一分配、调优和监控线程。管理员可以通过调整线程池的配置来优化性能，比如调整线程池大小、设置最大执行时间等。

4. 提供更强大的功能
   线程池提供了丰富的功能，比如线程池大小的动态调整、定时任务执行、任务队列管理和线程池状态的详细控制等。这些功能使得线程的管理更加灵活和强大。

5. 避免资源竞争导致的系统不稳定
   如果每个请求或任务都创建一个新线程，那么在高负载条件下，系统可能会创建大量线程，这会导致过多的上下文切换和内存消耗，甚至可能耗尽系统资源。线程池通过限制当前运行的线程数量，帮助避免这种情况，从而保持系统的稳定性。

6. 提供任务排队机制
   线程池通常与工作队列配合使用，当所有线程都忙时，新的任务会被放入队列中等待执行。这种排队机制使得任务处理更加平滑，避免了在高负载下的崩溃或拒绝服务。

综上所述，使用线程池而不是直接创建线程可以带来显著的性能优势和更好的资源管理，同时也使得多线程程序更加稳定和易于管理。

## 1. 线程池的七大参数

```java
ThreadPoolExecutor(int corePoolSize,
                   int maximumPoolSize,
                   long keepAliveTime,
                   TimeUnit unit,
                   BlockingQueue<Runnable> workQueue,
                   ThreadFactory threadFactory,
                   RejectedExecutionHandler handler)
```

- corePoolSize：核心线程数。线程池中始终运行的线程数量。
- maximumPoolSize：最大线程数。线程池中允许存在的最大线程数量。
- keepAliveTime：非核心线程的闲置超时时间。当线程池中线程数量超过核心线程数时，这些多余的线程在空闲时间达到 keepAliveTime 值时会被终止。
- unit：keepAliveTime 参数的时间单位。
- workQueue：任务队列。用于存放等待执行的任务的阻塞队列。
- threadFactory：线程工厂。用于创建新线程的工厂。
- handler：拒绝策略。当任务太多来不及处理，且工作队列已满时，用于处理被拒绝任务的策略。

## 2. 执行顺序

1. 核心线程的创建与任务执行
   当一个任务被提交到线程池时，线程池首先会考虑核心线程：

如果当前运行的线程少于核心线程数，线程池会尝试创建一个新的核心线程来执行提交的任务。
如果当前运行的线程数达到或超过核心线程数，线程池会将提交的任务放入工作队列中。

2. 工作队列的使用
   如果工作队列未满，新提交的任务会被放入队列中等待执行。线程池中的线程会从这个队列中取任务来执行。队列的类型对任务处理的顺序有显著影响：

如果是无界队列（如 LinkedBlockingQueue），则除非系统资源耗尽，否则所有提交的任务都会被加入队列等待执行，不会创建超过核心线程数的线程。
如果是有界队列（如 ArrayBlockingQueue），一旦队列满，且当前运行的线程数小于最大线程数，线程池会尝试创建新的线程来执行任务。

3. 超过核心线程数的线程创建
   如果工作队列已满，并且当前运行的线程数小于最大线程数，线程池会尝试创建新的线程来执行任务，而不是将任务放入队列中。

4. 任务拒绝策略
   如果工作队列已满，并且当前运行的线程数已经达到最大线程数，新提交的任务将会被拒绝。线程池提供了几种拒绝策略（如 AbortPolicy、CallerRunsPolicy 等），开发者可以根据需要选择适当的策略。

5. 线程回收
   对于非核心线程，如果在指定的空闲时间（keepAliveTime）内没有任务执行，线程池可能会决定终止并回收这些线程，以节省系统资源。

> 场景示例 假设一个线程池配置如下：

核心线程数（corePoolSize）：5

最大线程数（maximumPoolSize）：10

工作队列：基于 ArrayBlockingQueue 且容量为 100

在这个配置下，以下是可能的执行流程：

初始状态：当第一个任务提交给线程池时，如果当前运行的线程数小于核心线程数，线程池会立即创建一个新的核心线程来执行这个任务。

核心线程数达到上限：随着任务的持续提交，当线程池中的线程数达到 5（即核心线程数）后，新提交的任务会被加入到工作队列中，等待被执行。

工作队列已满：如果工作队列（容量为 100）已满，此时线程池中的线程数仍然小于最大线程数（10），那么线程池会创建新的线程来处理被提交的任务，直至线程数达到最大线程数（10）。

达到最大线程数：一旦线程数达到最大线程数（10），如果工作队列仍然满载，新提交的任务将会根据拒绝策略（RejectedExecutionHandler）来处理，例如抛出异常、在提交任务的线程中直接运行任务、丢弃任务等。

## 3.创建方式

Java 中的线程池主要通过 java.util.concurrent.ExecutorService 接口及其实现类来提供。ExecutorService 是一个更高级的线程管理接口，它能够管理线程的生命周期，包括线程的创建、运行、销毁等。Java 提供了几种不同类型的线程池，以适应不同的场景和需求。以下是 Java 标准库（Java SE）中提供的几种线程池：

1. FixedThreadPool
   固定大小的线程池。创建时你需要指定线程池中线程的数量。这种类型的线程池可以在执行长期的任务时提高性能。因为线程数是固定的，所以即使有任务等待执行也不会创建新的线程。

```java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);
```

2. CachedThreadPool
   可缓存的线程池。如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池通常用于执行大量的短期异步任务。

```java
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
```

3. SingleThreadExecutor
   单线程化的线程池，它只会用唯一的工作线程来执行任务，确保所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。适用于需要单独的线程按顺序执行任务的场景。

```java
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
```

4. ScheduledThreadPool
   固定大小的线程池，支持定时及周期性任务执行。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而不希望线程在执行完立即销毁。

```java
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(int corePoolSize);
```

5. WorkStealingPool (Java 8 引入)
   基于工作窃取算法的线程池。内部使用 ForkJoinPool 实现。这种类型的线程池适合大量的小任务，尤其是生成树状任务结构的场合。线程会尝试从一个队列的末尾窃取一个任务来执行，以减少线程间的竞争。

```java
ExecutorService workStealingPool = Executors.newWorkStealingPool();
```

6. ForkJoinPool (Java 7 引入)
   专为大规模并行任务设计的线程池，利用工作窃取算法来提高 CPU 的利用率。适合进行复杂的数据处理，如并行计算和异步任务。

```java
ForkJoinPool forkJoinPool = new ForkJoinPool();
```

每种类型的线程池都有其特定的使用场景。选择合适的线程池可以帮助提高程序的性能，降低系统的负载。
