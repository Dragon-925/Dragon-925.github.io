import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as r,c as o,a,e as n,b as e,d as l}from"./app-hwzvE8Ik.js";const c={},p=a("h1",{id:"《java类加载机制》",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#《java类加载机制》","aria-hidden":"true"},"#"),e(" 《Java类加载机制》")],-1),d=a("h2",{id:"一、类加载流程",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#一、类加载流程","aria-hidden":"true"},"#"),e(" 一、类加载流程")],-1),u={href:"https://imgse.com/i/pFFq0Nn",target:"_blank",rel:"noopener noreferrer"},v=a("img",{src:"https://s11.ax1x.com/2024/01/16/pFFq0Nn.md.png",alt:"pFFq0Nn.md.png",tabindex:"0",loading:"lazy"},null,-1),m=a("figcaption",null,"pFFq0Nn.md.png",-1),k=l(`<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过<strong>如下三步骤：</strong></p><h3 id="第一步-类的加载" tabindex="-1"><a class="header-anchor" href="#第一步-类的加载" aria-hidden="true">#</a> 第一步：类的加载</h3><p>（将class文件读入内存，并为之创建一个Java.lang.Class对象。此过程由类加载器完成）</p><h3 id="第二步-类的链接" tabindex="-1"><a class="header-anchor" href="#第二步-类的链接" aria-hidden="true">#</a> 第二步：类的链接</h3><p>（将类的二进制数据合并到jre中）</p><ul><li>验证：代码正确，是否安全</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li><li>虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程，<strong>也就是说虚拟机去直接找到我们的引用类型</strong></li></ul><h3 id="第三步-类的初始化" tabindex="-1"><a class="header-anchor" href="#第三步-类的初始化" aria-hidden="true">#</a> 第三步：类的初始化</h3><p>（JVM负责对类进行初始化）</p><ul><li>执行类构造器*&lt; clinit&gt;()<em>方法的过程。类构造器</em>&lt; clinit&gt;()<em>方法是由编译期自动收集所有被</em><strong>static</strong>*修饰的方法以及变量，合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li><li>双亲委派机制</li><li>虚拟机保证在多线程环境中被正确加锁和同步。</li></ul><h2 id="二、类加载器" tabindex="-1"><a class="header-anchor" href="#二、类加载器" aria-hidden="true">#</a> 二、类加载器</h2><h3 id="_1、类加载器的作用" tabindex="-1"><a class="header-anchor" href="#_1、类加载器的作用" aria-hidden="true">#</a> 1、类加载器的作用</h3><p>​ 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的<em><strong>java.lang.Class</strong></em>对象，作为方法区中类数据的访问入口</p><h3 id="_2、类的缓存" tabindex="-1"><a class="header-anchor" href="#_2、类的缓存" aria-hidden="true">#</a> 2、类的缓存</h3><p>​ 标准的JavaSE类加载器可以按照要求查找类，但一旦类被加载到类加载器中，他将维持加载（缓存）一段时间，不过JVM垃圾回（gc）收机制可以回收这些Class对象</p><h3 id="_3、类加载器展示" tabindex="-1"><a class="header-anchor" href="#_3、类加载器展示" aria-hidden="true">#</a> 3、类加载器展示</h3><p>类的加载是由类加载器完成的，类加载器分为两种。</p><ul><li><p>Java虚拟机自带的类加载器</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>系统类加载器</li></ul></li><li><p>用户自定义类加载器</p><ul><li><em>Java.lang.ClassLoader</em>的子类实例</li></ul></li></ul><h4 id="_1-根类加载器-引导类加载器" tabindex="-1"><a class="header-anchor" href="#_1-根类加载器-引导类加载器" aria-hidden="true">#</a> (1).根类加载器（引导类加载器）</h4><p>​ 根类加载器是最底层的类加载器，是虚拟机的一部分（JVM自带的类加载器），是由C++实现的，且没有父加载器，也没有继承<em>java.lang.ClassLoader</em>类。它主要负责Java平台核心库<em><strong>rt.jar</strong></em>（加载由系统属性&quot;<em>sun.boot.class.path</em>&quot;指定的路径下的核心类库，是由C++编写）（JAVA_HOME\\jre\\lib），出于安全考虑，根类加载器只加载Java、Javax、sun开头的类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">ClassLoder</span> loader <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//输出为：null</span>
    <span class="token comment">//因为根类加载器是由C++编写，所以Java并不能读取到</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-扩展类加载器" tabindex="-1"><a class="header-anchor" href="#_2-扩展类加载器" aria-hidden="true">#</a> (2).扩展类加载器</h4><p>​ 指原来SUN公司实现的<em>sun.misc.Launcher$ExtClassLoader</em>类（JDK9是<em>jdk.internal.loader.ClassLoaders$​​​PlatformClassLoader</em>类），由Java语言编写，父加载器是根类加载器。负责加载&lt;JAVA_HOME&gt;\\jre\\lib\\<mark>ext</mark>目录下的类库或者系统变量&quot;java.ext.dirs*&quot;指定的目录下的类库。</p><h4 id="_3-系统类加载器" tabindex="-1"><a class="header-anchor" href="#_3-系统类加载器" aria-hidden="true">#</a> (3).系统类加载器</h4><p>​ 也称为“应用类加载器”，也是纯Java类，是原来SUN公司实现的<em>snu.misc.Launcher$AppClassLoader</em>类(JDK9是<em>jdk.internal.loader.ClassLoaders$AppClassLoader)</em>。他的父加载器是扩展类加载器。它负责从classpath环境变量或者系统属性java.class.path所指定的目录中加载类。他是用户自定义的类加载器的默认父加载器。一般情况下，该类加载器是程序中默认的类加载器，可以通过*ClassLoader.getSystemClassLoader()*直接获得。加载我们自己项目也是最常用的加载器。</p><h4 id="_4-类加载器路径" tabindex="-1"><a class="header-anchor" href="#_4-类加载器路径" aria-hidden="true">#</a> (4)类加载器路径</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.class.path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\charsets.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\deploy.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\access-bridge-64.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\cldrdata.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\dnsns.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\jaccess.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\jfxrt.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\localedata.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\nashorn.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\sqljdbc4.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\sunec.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\sunjce_provider.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\sunmscapi.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\sunpkcs11.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\ext\\zipfs.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\javaws.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\jce.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\jfr.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\jfxswt.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\jsse.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\management-agent.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\plugin.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\resources.jar;
    * Z:\\Progrem Files\\Java\\jdk1.8.0_241\\jre\\lib\\rt.jar;
    * Z:\\JavaWorkSpace\\idea\\out\\production\\test01;
    * Z:\\Progrem Files\\idea\\IntelliJ IDEA 2021.1\\lib\\idea_rt.jar
    */</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-小结" tabindex="-1"><a class="header-anchor" href="#_5-小结" aria-hidden="true">#</a> (5).小结</h4><p>​ 在程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，同时我们可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时，才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件，Java虚拟机采用的时双亲委派机制，即把加载类的请求交给父加载器处理，如果父加载器处理不了，自己再处理，它是一种任务委派模式。</p><h2 id="三、双亲委派机制" tabindex="-1"><a class="header-anchor" href="#三、双亲委派机制" aria-hidden="true">#</a> 三、双亲委派机制</h2>`,29),h={href:"https://imgse.com/i/pFFqa7j",target:"_blank",rel:"noopener noreferrer"},b=a("img",{src:"https://s11.ax1x.com/2024/01/16/pFFqa7j.md.png",alt:"pFFqa7j.md.png",tabindex:"0",loading:"lazy"},null,-1),j=a("figcaption",null,"pFFqa7j.md.png",-1),g=l(`<p>​ 除了根类加载器之外，其他类加载器都需要有自己的父类加载器，从<em>JDK1.2</em>开始，类的加载过程采用双亲委派机制，这种机制能够很好的保护<em>Java</em>程序的安全。除了虚拟机自带的根类加载器之外，其余的类加载器都有唯一的父类加载器。也就是说除了根类加载器之外，其他的加载器都会现委托自己的父类加载器去执行（如果不行，一直推到根类加载器），如果父类不行，再自己执行。真正加载类的加载器我们叫做<strong>启动类加载器</strong></p><blockquote><p>注意：双亲委派机制的父子关系并非面向对象程序设计中的继承关系，而是通过使用<strong>组合模式</strong>来复用父加载器代码</p></blockquote><ul><li><strong>使用双亲委派机制的好处</strong><ul><li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子类ClassLoader再加载一次。</li><li>考虑安全因素，Java核心API中定义类型不会被随意替换，假设通过网络传递一个名为“java.lang.Object”的类，通过双亲委派机制传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的java.lang.Object，而直接返回已经加载过的Object.class，这样便可以防止核心API库被随意篡改。</li></ul></li></ul><h2 id="四、classloader" tabindex="-1"><a class="header-anchor" href="#四、classloader" aria-hidden="true">#</a> 四、ClassLoader</h2><p>​ 所有类加载器（除了跟类加载器）都必须继承java.lang.ClassLoader（是一个抽象类）。主要方法如下：</p><ul><li><h3 id="loadclass" tabindex="-1"><a class="header-anchor" href="#loadclass" aria-hidden="true">#</a> loadClass</h3><p>​ 在ClassLoader源码中，有一个方法loadClass(String name,boolean resolve)，这里就是双亲委派机制的代码实现。从源码中可以了解它的执行顺序。需要注意的是，只有父类加载器加载不到类的时候，会调用findClass方法进行类的查找，所以在定义自己的类加载器时，不能覆盖掉该方法，而应该覆盖掉findClass方法。</p><blockquote><p>使用指定二进制名称类加载类，此方法的默认实现将按以下顺序搜索类</p><p>1.调用***findLoadedClass(String)***检查是否已经加载类</p><p>2.在父类加载器上调用<em><strong>loadClass</strong></em>方法。如果父类加载器为null，则使用虚拟机的内置类加载器。</p><p>3.调用***findClass(String)***方法查找类。</p></blockquote><p>​ <mark>使用上述步骤找到类，并且<em><strong>resolve</strong></em>标志为真，则此方法将在得到的Class对象上调用<em><strong>resolveClass(Class)<em><strong>方法。鼓励用ClassLoader的子类重写</strong></em>findClass(String)</strong></em>，而不是使用此方法。</mark></p></li><li><h3 id="findclass" tabindex="-1"><a class="header-anchor" href="#findclass" aria-hidden="true">#</a> findClass</h3><p>​ 在自定义类加载器时，一般我们需要覆盖这个方法，且ClassLoader中给出了一个默认的错误实现。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><h3 id="defineclass" tabindex="-1"><a class="header-anchor" href="#defineclass" aria-hidden="true">#</a> defineClass</h3><p>​ 该方法的签名如下，用来将byte字节解析成虚拟机能够识别的Class对象。defineClass()方法通常与findClass()方法一起使用。在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法获取要加载类的字节码，然后调用defineClass()方法生成Class对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassFormatError</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><h3 id="resolveclass" tabindex="-1"><a class="header-anchor" href="#resolveclass" aria-hidden="true">#</a> resolveClass</h3><p>​ 连接指定类，类加载器可以使用此方法来连接。</p></li></ul><h2 id="五、urlclassloader" tabindex="-1"><a class="header-anchor" href="#五、urlclassloader" aria-hidden="true">#</a> 五、URLClassLoader</h2><p>​ 在java.net包中，JDK提供了一个更加易用的类加载器URLClassLoader，它扩展了ClassLoader，能够从本地或者网上指定的位置加载类。我们可以使用子类作为自定义类加载器使用。</p><p>构造方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">URLClassLoader</span><span class="token punctuation">(</span><span class="token constant">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">)</span><span class="token comment">//指定要加载的类所在的URL地址，父类加载器默认为系统类加载器</span>
<span class="token keyword">public</span> <span class="token class-name">URLClassLoader</span><span class="token punctuation">(</span><span class="token constant">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">,</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span><span class="token comment">//指定要加载的类所在的URL地址，并指定父类加载器</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,10);function _(f,C){const s=t("ExternalLinkIcon");return r(),o("div",null,[p,d,a("figure",null,[a("a",u,[v,n(s)]),m]),k,a("figure",null,[a("a",h,[b,n(s)]),j]),g])}const F=i(c,[["render",_],["__file","Java类加载机制.html.vue"]]);export{F as default};
